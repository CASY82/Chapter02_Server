# Redis를 활용한 캐싱 전략

### 배경
현재 애플리케이션은 여러 시퀀스 다이어그램(결제, 예약, 좌석 조회, 일정 조회, 포인트 조회/충전 등)을 기반으로 동작하며, 데이터 조회 성능과 응답 시간을 개선하기 위해 Redis를 활용한 캐싱 전략을 도입하고자 합니다. 자주 조회되거나 변경 빈도가 낮은 데이터, 또는 조회에 시간이 오래 걸리는 데이터를 캐싱하여 애플리케이션의 요청 처리 성능을 향상시키는 것이 목표입니다다.

### 문제

성능 병목: 예약 가능 좌석 조회, 일정 조회, 포인트 잔액 조회 등에서 데이터베이스 조회가 빈번하게 발생하며, 이로 인해 응답 시간이 지연될 수 있습니다.  
데이터 특성: 일부 데이터(예: 공연 일정, 좌석 정보)는 자주 변경되지 않으며, 자주 조회되는 특성을 가집니다.  
확장성: 사용자 트래픽이 증가할 경우, 데이터베이스 부하를 줄이고 응답 시간을 유지하기 위한 전략이 필요합니다.  

### 의사결정

Redis를 활용한 캐싱 전략을 다음과 같은 구간에 적용하며, 각 구간에 적합한 캐시 전략을 선정한다. 캐싱 대상은 조회 시간이 오래 걸리거나 변경 빈도가 낮은 데이터로 한정합니다.

#### 1. 예약 가능 일정 조회

- 구간

시퀀스 다이어그램: 예약 가능 날짜 요청 (GET /api/schedules?performance_id={id})  
대상: ScheduleRepo에서 조회된 예약 가능 일정 목록 (performance_ref_id, schedule_date_time >= now)  

- 캐시 전략

Cache-Aside (Lazy Loading):
클라이언트가 요청 시 Redis에서 데이터를 조회하고, 캐시에 없으면 데이터베이스에서 조회 후 Redis에 저장.  
일정 데이터는 공연별로 고유하며, 공연 일정이 자주 변경되지 않는 특성을 고려.  


TTL 설정: 1시간 (공연 일정은 일반적으로 하루 단위로 안정적이며, 변경 시 캐시 무효화 가능).  
캐시 키: schedules:performance:{performance_id}  
캐시 무효화:
공연 일정 추가/수정/삭제 시 해당 performance_id에 대한 캐시를 무효화.
Redis DEL 명령어로 캐시 제거 또는 새 데이터로 갱신.  

- 이유

공연 일정은 자주 조회되지만, 데이터 변경 빈도가 낮아 캐싱에 적합.  
Cache-Aside는 구현이 간단하며, 데이터베이스 부하를 줄이는 데 효과적.  


#### 2. 예약 가능 좌석 조회

- 구간

시퀀스 다이어그램: 예약 가능 좌석 요청 (GET /api/seats?schedule_id={id})  
대상: SeatRepo에서 조회된 공연장 좌석 목록 및 SeatReservationRepo에서 확인된 예약되지 않은 좌석 정보.  

- 캐시 전략

Write-Through:
좌석 예약 상태는 예약 생성/취소 시 즉시 변경되므로, 데이터베이스 업데이트와 함께 Redis 캐시를 동기적으로 갱신.  
좌석 목록은 공연장별로 고유하며, 예약 상태는 동적으로 변동.  


TTL 설정: 5분 (좌석 예약 상태는 빠르게 변동될 수 있으므로 짧은 TTL로 설정).  
캐시 키: seats:schedule:{schedule_id}  
캐시 무효화:
좌석 예약 생성(POST /api/reservations) 또는 취소(Scheduler에 의한 PENDING 예약 취소) 시 해당 schedule_id에 대한 캐시 갱신.  
SeatReservationRepo 업데이트와 함께 Redis 캐시를 동기적으로 갱신.  

- 이유

좌석 정보는 빈번히 조회되며, 예약 상태 변경이 빈번하므로 Write-Through 전략으로 캐시와 데이터베이스 간 일관성을 유지.  
짧은 TTL로 캐시 만료를 통해 최신 데이터를 보장.  


#### 3. 포인트 잔액 조회

- 구간

시퀀스 다이어그램: 포인트 잔액 조회 요청 (GET /api/points/balance)  
대상: PointRepo에서 조회된 포인트 잔액 (remain_point).  

- 캐시 전략

Cache-Aside:
포인트 잔액은 사용자별로 고유하며, 자주 조회되지만 포인트 충전/사용 시에만 변경.  
Redis에서 캐시 조회 후 없으면 데이터베이스에서 조회 및 캐시 저장.  

TTL 설정: 10분 (포인트 잔액은 비교적 안정적이며, 짧은 TTL로 최신성 유지).  
캐시 키: points:balance:{user_ref_id}  
캐시 무효화:
포인트 충전(POST /api/points/charge) 또는 결제 시 포인트 사용(POST /api/payments) 후 해당 user_ref_id에 대한 캐시 무효화.  
Redis DEL 명령어로 캐시 제거.  

- 이유

포인트 잔액 조회는 사용자 경험에 직접적인 영향을 미치며, 빈번한 조회로 인해 캐싱 효과가 큼.  
Cache-Aside는 데이터 변경 빈도가 낮은 포인트 잔액에 적합하며, 간단한 구현으로 성능 향상 가능.  

#### 4. 공연 정보 조회

- 구간

시퀀스 다이어그램: 예약 가능 날짜 요청 (GET /api/schedules?performance_id={id})  
대상: PerformanceRepo에서 조회된 공연 정보.  

- 캐시 전략

Cache-Aside:
공연 정보는 공연별로 고유하며, 공연 세부 정보(제목, 장소 등)는 거의 변경되지 않음.  
Redis에서 캐시 조회 후 없으면 데이터베이스에서 조회 및 캐시 저장.  

TTL 설정: 24시간 (공연 정보는 매우 안정적이며, 변경 시 수동 무효화 가능).  
캐시 키: performance:{performance_id}  
캐시 무효화:
공연 정보 수정/삭제 시 해당 performance_id에 대한 캐시 무효화.  
Redis DEL 명령어로 캐시 제거.  

- 이유

공연 정보는 모든 일정 조회 요청에서 필수적으로 조회되며, 변경 빈도가 매우 낮아 캐싱 효과가 큼.  
긴 TTL로 캐시 유지 시간을 늘려 데이터베이스 부하를 최소화.  


### 대안

Write-Back:
캐시에 먼저 쓰고 비동기적으로 데이터베이스에 반영.  
데이터 일관성 유지가 어려우며, 좌석 예약과 같은 동시성 이슈가 있는 구간에서 위험.  
구현 복잡도가 높아 채택하지 않음.  

Cache-Aside with Preloading:
애플리케이션 시작 시 모든 데이터를 캐시에 미리 로드.  
데이터 크기가 클 경우 메모리 사용량이 증가하며, 초기 로드 시간이 길어질 수 있음.  
동적 데이터(좌석 예약 상태 등)에 부적합하여 제한적으로 적용 가능.  


### 결과

예상 효과:
데이터베이스 부하 감소: 자주 조회되는 데이터의 캐싱으로 쿼리 횟수 감소.  
응답 시간 단축: Redis의 빠른 읽기 성능으로 사용자 경험 개선.  
확장성 향상: 트래픽 증가 시 데이터베이스 부하를 캐시로 분산.  


구현 우선순위:
예약 가능 좌석 조회 (빈번한 조회, 동적 데이터).  
포인트 잔액 조회 (사용자 경험에 직접적 영향).  
예약 가능 일정 조회 및 공연 정보 (정적 데이터, 높은 캐싱 효과).  

### 작업 목록

Redis 클러스터 설정 및 연결 풀 구성.  
캐시 키 패턴 및 TTL 정책 코드로 구현.  
캐시 무효화 로직을 각 서비스 레이어에 통합.  
캐시 히트율 및 응답 시간 모니터링 도구 도입(Prometheus, Grafana 등).  